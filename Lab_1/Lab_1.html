<!DOCTYPE html>
<html lang="pt">
<head>
<title>LAB 1</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
{
  box-sizing: border-box;
}

body {
  font-family: Arial, Helvetica, sans-serif;
}

header {
  background-color: #6a8d3c;
  padding: 10px;
  text-align: center;
  font-size: 35px;
  color: white;
}

section {
  display: -webkit-flex;
  display: flex;
}

nav {
  -webkit-flex: 1;
  -ms-flex: 1;
  flex: 1;
  background: #ccc;
  padding: 20px;
}

nav ul {
  list-style-type: none;
  padding: 0;
}

article {
  -webkit-flex: 3;
  -ms-flex: 3;
  flex: 3;
  background-color: #f1f1f1;
  padding: 12px;
}

footer {
  background-color: #708090;
  padding: 10px;
  text-align: center;
  color: white;
}

.code-box {
            background-color: #f4f4f4;
            border: 1px solid #ddd;
            padding: 0;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre;
            width: 800px; 
            margin: 0 auto; 
            overflow-x: auto; 
}

figcaption {
    font-size: 14px;
    color: #555;
    margin-top: 5px;
}


@media (max-width: 600px) {
  section {
    -webkit-flex-direction: column;
    flex-direction: column;
  }
}
</style>
</head>
<body>

<header>
    <h1>ESZA019-17SA - Visão Computacional</h1>
    <h3>Lab 01 - Captura de Imagem e Vídeo</h3>
    <h5>Integrantes
    <br>Diego Aoyagi de Souza - RA: 11066516
    <br>Gabriel Gomes de Oliveira - RA: 11108214
    <br>Gustavo Cardoso Bezerra- RA: 11201822553</h5>
    <h6>Data do Experimento: 25/06/2024
    <br>Data de publicação: 02/07/2024</h6>
</header>

<section>  
  <article> <!-- Texto central que indica a introdução do laboratório em questão-->
    <h2><center>Introdução</center></h2>
    <p><justify>A captura de imagens e vídeos é uma função essencial em diversas aplicações de processamento de imagens e visão computacional. Ela permite a aquisição de dados visuais em tempo real ou a partir de fontes armazenadas, facilitando análises, manipulações e processamentos subsequentes. No contexto do OpenCV, uma biblioteca popular para essas tarefas em Python, a captura é realizada através de interfaces simples e poderosas que permitem desde a obtenção de frames individuais até o processamento contínuo de fluxos de vídeo. Este processo não apenas viabiliza a aplicação de algoritmos de análise visual, mas também proporciona a base para a criação de sistemas interativos e automatizados que dependem de entrada visual em tempo real. 
      O experimento conduzido no laboratório visa familiarizar os participantes com os comandos fundamentais do OpenCV para visualização e gravação de imagens e vídeos. Para isso, organizamos grupos de três membros para executar as tarefas detalhadas no relatório fornecido. Utilizando programas em Python e imagens pré-existentes, além de capturas de novas imagens, adaptamos os códigos baseados em algumas referências tendo como principal a documentação oficial do OpenCV para resolver uma variedade de atividades propostas, incluindo a modificação de cores das imagens, captura de imagens e vídeos, e controle da velocidade de reprodução dos vídeos.</justify></p>


    <br>
    <h2><center>Procedimentos experimentais</center></h2>
    <p><justify>Baixar os arquivos de referência para serem utilizados em aula, bem como as programações utilizadas e salvar numa pasta individual. Nessa mesma pasta, ativar o ambiente virtual criado anteriormente;

      Executar a primeira programação “python3 L1_1_img.py”, e através da análise do código presente no arquivo, estudo de referências e seguindo outros exemplos, identificar o motivo da imagem aparecer em escala de cinza;
      
      Executar o arquivo “python3 L1_2_video.py” e modificar o código com intuito de alterar a velocidade de exibição do vídeo “big buck bunny” disponibilizado.
      
      Ligar a Webcam disponibilizada pelo laboratório no computador e utilizando o algoritmo  “L1_3_webcam.py” fazer a leitura de uma sequência de imagens que serão posteriormente mostradas na tela do computador. Para isso deve-se modificar o código base presente com intuito de capturar as imagens ao pressionar a tecla”x” no teclado.
      
      Uma vez feita a captação de imagens, é hora de obter uma gravação de vídeo através da leitura do programa “L1_4_webcap.py” que irá fazer a captura de uma sequência de imagens e ao apertar o botão “q” salva essa sequência em um arquivo de extensão .avi e para que elas sejam exibidas numa velocidade aceitável, deve ser feito uma modificação no código base.
      
      Para executar a segunda parte do experimento, vamos utilizar a webcam e os conhecimentos adquiridos na parte 1 deste experimento para desenvolver as atividades.
      
      Na primeira atividade devemos utilizar partes dos códigos existentes para formar um programa que capta uma imagem que contenha os integrantes do grupo;
      
      Na segunda atividade vamos capturar uma sequência de quatro vídeos, sendo dois deles com pessoas e dois com um objetos. O objetivo é gravar os vídeos como diferentes velocidades de execução de movimentos e com pessoas diferentes
      
      Na terceira atividade, devemos utilizar algum software de edição de imagens para compor uma só imagem concatenando 3 imagens diferentes contendo o avatar de cada integrante do grupo, na mesma ordem da foto capturada na primeira atividade da parte 2.
      </justify></p>

    <br>
	  <h2><center>Parte 1</center></h2>
	  		<p><center> <b>Pergunta A - Responda:</b> por que a janela aberta não mostra a imagem colorida? 

                    <br><b>Resposta:</b> O código abre a imagem em preto e branco porque na linha img = cv.imread('messi5.jpg',0), o parâmetro 0 indica que a imagem deve ser lida em escala de cinza.
          
                    A função cv.imread do OpenCV é utilizada para ler imagens de arquivos. Quando você passa o segundo argumento como 0 (zero), isso especifica que a imagem deve ser carregada em modo de escala de cinza. Isso significa que a imagem será convertida para uma representação em tons de cinza, onde cada pixel terá apenas um valor representando a intensidade luminosa, ao invés de três valores (para os canais de cor vermelho, verde e azul) como em uma imagem colorida.
        </center	></p>

        <p><center> <b>Pergunta B - Altere:</b> modifique o programa para que as imagens sejam exibidas mais rapidamente e depois para que sejam exibidas mais lentamente. Responda: qual a explicação de alteração de velocidade de exibição, e apresente suas soluçõe detalhadamente.
                    <br><b>Resposta:</b> O controle da velocidade de exibição é definida na linha 15 do script, onde está definido     “time.sleep(1/25.0)”, desta forma, se queremos aumentar a velocidade, o denominador da fração deve ser maior que 25.0 e caso quisermos diminuir a velocidade, devemos diminuir o denominador para alterar o tempo de espera entre um frame e o outro
            
        </center	></p>

        <p><center> <b>Pergunta C - Altere:</b> modifique o programa para que uma imagem da câmera seja salva num arquivo “foto1.png” no momento em que for clicada a tecla ‘x’ no teclado. Apresente o resultado e sua solução detalhadamente.
                    <br><b>Resposta:</b> Para salvar a imagem, utilizamos um if que aguarda o pressionamento da tecla x e caso seja pressionada, o frame é salvo no arquivo foto1.png e o programa é encerrado.
          
        </center	></p>

      
        <pre class="code-box">
          <code>
              <h3>
                import numpy as np
                import cv2 as cv
                
                
                cap = cv.VideoCapture(0)
                
                
                if not cap.isOpened():
                   print("Cannot open camera")
                   exit()
                  
                while True:
                   # Capture frame-by-frame
                   ret, frame = cap.read()
                   # if frame is read correctly ret is True
                   if not ret:
                       print("Can't receive frame (stream end?). Exiting ...")
                       break
                  
                   # Display the resulting frame
                   cv.imshow('frame', frame)
                  
                   if cv.waitKey(1) == ord('x'):
                       # Salva o frame na foto1.png
                       cv.imwrite('foto1.png',frame)
                       break
                      
                   if cv.waitKey(1) == ord('q'):
                       break
                
                
                # When everything done, release the capture
                cap.release()
                cv.destroyAllWindows()
                </h3>  
          </code>
        </pre>
      <center><figcaption>Código python utilizado na resolução da questão C</figcaption><p></center>
        
      

        <p><center> <b>Pergunta D - Altere:</b> modifique o programa para que as imagens gravadas estejam “normais” no arquivo de video salvo, e apresentem uma velocidade de exibição adequada. Apresente o resultado e sua solução detalhadamente.
                    <br><b>Resposta:</b> Para exibir a imagem normal, retiramos a linha que realizava o flip da imagem, dessa forma a imagem é exibida na forma original e além disso realizamos a alteração da variável “fps” para 30.0, dessa forma o vídeo iŕa exibir 30 frames por segundo.
          
        </center	></p>

        <pre class="code-box">
          <code>
              <h3>
                import numpy as np
                import cv2 as cv
                cap = cv.VideoCapture(0)


                # Get current width of frame
                width = cap.get(cv.CAP_PROP_FRAME_WIDTH)   # float
                # Get current height of frame
                height = cap.get(cv.CAP_PROP_FRAME_HEIGHT) # float
                # Define Video Frame Rate in fps
                fps = 30.0


                # Define the codec and create VideoWriter object
                fourcc = cv.VideoWriter_fourcc(*'XVID')
                out = cv.VideoWriter('saida.avi', fourcc, fps, (int(width),int(height)) )


                while cap.isOpened():
                   ret, frame = cap.read()
                   if not ret:
                       print("Can't receive frame (stream end?). Exiting ...")
                       break
                   #frame = cv.flip(frame, 0)
                   # write the flipped frame
                   out.write(frame)
                   cv.imshow('frame', frame)
                   if cv.waitKey(1) == ord('q'):
                       break


                # Release everything if job is finished
                cap.release()
                out.release()
                cv.destroyAllWindows()

                </h3>  
          </code>
        </pre>
        <center><figcaption>Código python utilizado na resolução da questão D</figcaption><p></center>

        <br>
        <h2><center>Análise e discussão dos estudos realizados</center></h2>
        <p><justify>Os estudos realizados no laboratório demonstraram a versatilidade e a robustez do OpenCV como uma ferramenta para captura e processamento de imagens e vídeos. Os exercícios práticos permitiram explorar diferentes aspectos da biblioteca, desde a simples leitura e exibição de imagens até a captura de vídeo em tempo real. A compreensão dos conceitos básicos e a habilidade de modificar parâmetros para ajustar resultados foram algumas das competências desenvolvidas nesse laboratório.</justify></p>

        <br>
        <h2><center>Conclusão</center></h2>
        <p><justify>Concluindo, o laboratório de captura de imagem e vídeo proporcionou uma experiência valiosa no uso do OpenCV. Os participantes aprenderam a importância de configurar corretamente parâmetros e a utilizar comandos básicos para manipulação de imagens e vídeos. As habilidades adquiridas durante este experimento formam a base para desenvolvimentos mais avançados em visão computacional, capacitando a equipe a criar sistemas interativos e automatizados que dependem de entrada visual em tempo real.
        </justify></p>

				<br>
	      <h2><center>Parte 2</center></h2>
	  		<p><center> Foto de todos os integrantes.</center	></p>
				<p><center><img src="todos.png" alt="Foto de todos os integrantes"></center></p>
				
        <p><center> Foto de todos os avatares.</center	></p>
        <p><center><img src="avatar.png" alt="Foto de todos os avatares"></center></p>
	  
	  	  <p><center>Vídeos Rapidos</center></p>
        <p><center><video src="saida_1.mp4" width="600" controls autoplay loop></video>
	        <video src="saida_2.mp4" width="600" controls autoplay loop></video></center></p>
        <p><center>Vídeos Lentos</center></p>

        <p><center><video src="saida_3.mp4" width="600" controls autoplay loop></video>
        <video src="saida_4.mp4" width="600" controls autoplay loop></video></center></p>
        
        <br>
        <h2><center>Referências</center></h2>
        <p><justify><center>
          Analytical, C. N. S. [@cnsanalytical6835]. ([s.d.]). 🚀 curso OpenCV Python - português. Youtube. Recuperado 25 de junho de 2024, de http://www.youtube.com/playlist  list=PLsyobOqUhkthjvmA_s7tTjb7V2EiwYYGC
          <br>OpenCV: Getting started with images. ([s.d.]). Opencv.org. Recuperado 25 de junho de 2024, de https://docs.opencv.org/4.x/db/deb/tutorial_display_image.html
          <br>OpenCV: Getting started with videos. ([s.d.]). Opencv.org. Recuperado 25 de junho de 2024, de https://docs.opencv.org/4.x/dd/d43/tutorial_py_video_display.html
          <br>OpenCV: OpenCV-Python Tutorials. ([s.d.]). Opencv.org. Recuperado 25 de junho de 2024, de https://docs.opencv.org/master/d6/d00/tutorial_py_root.html
        </center></justify></p>

  </article>
</section>

<footer>
  <p>2º Quadrimestre 2024</p>
</footer>

</body>
</html>